"""Classes for modelling the stations of a queueing model"""

from typing import Any, Optional
import random
from .descore import Event, Simulator
from .statistics import RecordDiscrete, RecordContinuous, RecordOptions


__title__ = "queuesim"
__version__ = "1.0"
__author__ = "Alexander Herzog"
__email__ = "alexander.herzog@tu-clausthal.de"
__copyright__ = """
Copyright 2022 Alexander Herzog

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
__license__ = "Apache 2.0"


class _SendEvent(Event):
    """Event for forwarding a client to a specific station (generated by Client.send_to)."""
    __slots__ = ("__station", "__client")

    def __init__(self, simulator: Simulator, time: float, station, client):
        """Event for forwarding a client to a specific station.

        Args:
            simulator (Simulator): Simulator object
            time (float): Scheduled execution time of the event
            station ([type]): Station to which the client should be directed
            client ([type]): Client to be forwarded to the station
        """
        super().__init__(simulator, time)
        self.__station: Station = station
        self.__client: Client = client

    def run(self) -> None:
        self.__station.arrival(self.__client)


class Client:
    """Client object."""
    __slots__ = ("__simulator", "__type_name", "__waitingTime", "__serviceTime", "stationArrivalTime", "removeEvent")

    def __init__(self, simulator: Simulator, type_name: str) -> None:
        """Client object.

        Args:
            simulator (Simulator): Simulator object
            type_name (str): Name of client type
        """
        self.__simulator: Simulator = simulator
        self.__type_name: str = type_name
        self.__waitingTime: float = 0
        self.__serviceTime: float = 0
        self.stationArrivalTime: float = 0
        self.removeEvent: Optional[Event] = None

    def add_waiting(self, time: float) -> None:
        """Record a specific period of time as waiting time (will be added to the existing waiting time).

        Args:
            time (float): Waiting time to be added
        """
        self.__waitingTime += time

    def add_service(self, time: float) -> None:
        """Record a specific period of time as service time (will be added to the existing service time).

        Args:
            time (float): Service time to be added
        """
        self.__serviceTime += time

    def send_to(self, station) -> None:
        """Forwards the client to another station.
        (The forwarding does not take place immediately, but only after the current event has been processed).

        Args:
            station (Station): Destination station
        """
        _SendEvent(self.__simulator, self.__simulator.time, station, self)

    @property
    def type_name(self) -> str:
        """Type name of the current client.

        Returns:
            str: Type name of the current client.
        """
        return self.__type_name

    @property
    def waiting_time(self) -> float:
        """Current waiting time of the client.

        Returns:
            float: Current waiting time of the client
        """
        return self.__waitingTime

    @property
    def service_time(self) -> float:
        """Current service time of the client.

        Returns:
            float: Current service time of the client
        """
        return self.__serviceTime


class StationEvent(Event):
    """Event to notify a station about internal processes
    (generated by Station.generate_event and processed by Station.event).
    """
    __slots__ = ("station", "client")

    def __init__(self, simulator: Simulator, time: float, station, client: Optional[Any] = None):
        """Event to notify a station about internal processes.

        Args:
            simulator (Simulator): Simulator object
            time (float): Scheduled execution time of the event
            station ([type]): Station to be notified
            client (Optional[Any], optional): Client object. Defaults to None.
        """
        super().__init__(simulator, time)
        self.station = station
        self.client: Optional[Client] = client

    def run(self) -> None:
        self.station.event(self.client)


class Station:
    """Basic implementation for stations."""
    __slots__ = ("__simulator", "__lastArrivalTime", "__statistic")

    def __init__(self, simulator: Simulator) -> None:
        """Basic implementation for stations.

        Args:
            simulator (Simulator): Simulator object
        """
        self.__simulator: Simulator = simulator
        self.__lastArrivalTime: float = 0
        self.__statistic: RecordDiscrete = RecordDiscrete()
        self.__simulator.register_init(self)

    @property
    def simulator(self) -> Simulator:
        """Simulator object

        Returns:
            Simulator: Simulator object
        """
        return self.__simulator

    def init(self) -> None:
        """Invoked by the simulator system at the beginning of event processing."""
        pass

    def arrival(self, client: Client) -> None:
        """Notifies the station that a client has arrived.

        Args:
            client (Client): New arrived client
        """
        time: float = self.time
        client.stationArrivalTime = time
        self.__statistic.record(time - self.__lastArrivalTime)
        self.__lastArrivalTime = time

    def event(self, client: Optional[Any]) -> None:
        """Invoked by self-generated events (generated by Station.generate_event).

        Args:
            client (Optional[Any]): Client or list of clients or also None; additional information for the station
        """
        pass

    def generate_event(self, delta: float, client: Optional[Any] = None) -> None:
        """Creates an event by which the station later informs itself about internal processes
        (processed by Station.event).

        Args:
            delta (float): Time delay from current time
            client (Optional[Any], optional): Client or list of clients or also None; additional information for the station
        """
        StationEvent(self.__simulator, self.__simulator.time + max(0, delta), self, client)

    @property
    def time(self) -> float:
        """Current simulation time

        Returns:
            float: Current simulation time
        """
        return self.__simulator.time

    @property
    def statistic(self) -> RecordDiscrete:
        """Statistics about the arrivals at the station.

        Returns:
            RecordDiscrete: Statistics about the arrivals at the station
        """
        return self.__statistic

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        return []

    def clear_lambdas(self) -> None:
        """Deletes all data fields that are only relevant during the simulation itself and would prevent serialization."""
        self.__statistic.done_recording()


class Source(Station):
    """Station: Client source."""
    __slots__ = ("__toBeSimulated", "__count", "__getI", "__getB", "__type_name", "__nextStation")

    def __init__(self, simulator: Simulator, count: int, getI: Any, getB: Any = None, client_type_name: str = "clients") -> None:
        """Station: Client source.

        Args:
            simulator (Simulator): Simulator object
            count (int): Number of client arrivals to be simulated
            getI (Any): Generates the individual inter-arrival times (must be a lambda or a string that can be evaluated to a lambda)
            getB (Any, optional): Generates the individual batch sizes (must be a lambda, a string that can be evaluated to a lambda, or None). If None is passed, a constant batch size of 1 is assumed. Defaults to None.
            client_type_name (str, optional): Type name of the client generated at this station. Defaults to "clients".
        """
        super().__init__(simulator)
        self.__toBeSimulated: int = count
        self.__count: int = 0
        self.__getI = getI
        self.__getB = getB
        self.__type_name: str = client_type_name
        self.__nextStation = None

    def set_next(self, station: Station) -> None:
        """Sets the next station.

        Args:
            station (Station): Next station
        """
        self.__nextStation: Optional[Station] = station

    def init(self) -> None:
        super().init()
        self._schedule_next_arrival()

    def _schedule_next_arrival(self) -> None:
        if self.__count >= self.__toBeSimulated: return
        self.__count += 1
        if isinstance(self.__getI, str): self.__getI = eval(self.__getI)
        if self.__getI is not None: self.generate_event(self.__getI())

    def arrival(self, client: Client) -> None:
        super().arrival(client)
        client.send_to(self.__nextStation)

    def event(self, client: Optional[Client]) -> None:
        if isinstance(self.__getB, str): self.__getB = eval(self.__getB)
        b = self.__getB() if self.__getB is not None else 1
        for i in range(0, b): self.arrival(Client(self.simulator, self.__type_name))
        self._schedule_next_arrival()

    @property
    def count(self) -> int:
        """Number of client arrivals to be simulated.

        Returns:
            int: Number of client arrivals to be simulated
        """
        return self.__toBeSimulated

    @property
    def client_type_name(self) -> str:
        """Name of the clients generated at this source station.

        Returns:
            str: Name of the clients generated at this source station.
        """
        return self.__type_name

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        if self.__nextStation is None: return []
        return [self.__nextStation]

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__getI = None
        self.__getB = None
        self.__nextStation = None


class Dispose(Station):
    """Station: Dispose."""
    __slots__ = ("__statisticClientWaiting", "__statisticClientService", "__statisticClientResidence")

    def __init__(self, simulator: Simulator) -> None:
        """Station: Dispose.

        Args:
            simulator (Simulator): Simulator object
        """
        super().__init__(simulator)
        self.__statisticClientWaiting: RecordDiscrete = RecordDiscrete()
        self.__statisticClientService: RecordDiscrete = RecordDiscrete()
        self.__statisticClientResidence: RecordDiscrete = RecordDiscrete()

    def arrival(self, client: Client) -> None:
        super().arrival(client)
        self.__statisticClientWaiting.record(client.waiting_time)
        self.__statisticClientService.record(client.service_time)
        self.__statisticClientResidence.record(client.waiting_time + client.service_time)

    @property
    def statistic_client_waiting(self) -> RecordDiscrete:
        """Waiting times of clients leaving the system via this station.

        Returns:
            RecordDiscrete: Waiting times of clients leaving the system via this station
        """
        return self.__statisticClientWaiting

    @property
    def statistic_client_service(self) -> RecordDiscrete:
        """Service times of clients leaving the system via this station.

        Returns:
            RecordDiscrete: Service times of clients leaving the system via this station
        """
        return self.__statisticClientService

    @property
    def statistic_client_residence(self) -> RecordDiscrete:
        """Residence times of clients leaving the system via this station.

        Returns:
            RecordDiscrete: Residence times of clients leaving the system via this station
        """
        return self.__statisticClientResidence

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__statisticClientWaiting.done_recording()
        self.__statisticClientService.done_recording()
        self.__statisticClientResidence.done_recording()


class _WaitingCancelationEvent(StationEvent):
    def run(self) -> None:
        self.station.waiting_cancelation_event(self.client)


class Process(Station):
    """ Station: Process station."""
    __slots__ = ("__getS", "__getS_client_type", "__getS2", "__getNu", "__getNu_client_type", "__c", "__cBusy", "__K", "__b", "__FIFO", "__getPriority", "__wip", "__queue", "__nextStationCancel", "__statisticStationWaiting", "__statisticStationService", "__statisticStationPostProcessing", "__statisticStationResidence", "__statisticSuccess", "__statisticQueueLength", "__statisticWIP", "__statisticWorkload", "__nextStation")

    def __init__(self, simulator: Simulator, getS: Any, c: int, getNu: Any = None, getS2: Any = None, K: int = -1, b: int = 1, LIFO: bool = False, getPriority: Any = None, record_values: bool = False, getS_client_type: Any = None, getNu_client_type: Any = None) -> None:
        """ Station: Process station.

        Args:
            simulator (Simulator): Simulator object
            getS (Any): Generates the individual service times (must be a lambda or a string that can be evaluated to a lambda)
            c (int): Number of operators
            getNu (Any, optional): Generates the individual wait time tolerances (must be a lambda, a string that can be evaluated to a lambda, or None). If None is passed, the clients are arbitrarily patient. Defaults to None.
            getS2 (Any, optional): Generates the individual postprocessing times (must be a lambda, a string that can be evaluated to a lambda, or None). If None is passed, there are no post processing times. Defaults to None.
            K (int, optional): Size of the waiting and service room. Must be greater than or equal to c, or else -1 for "unlimited". Defaults to -1.
            b (int, optional): Service batch size. Defaults to 1.
            LIFO (bool, optional): Operation according to FIFO rule (False) or LIFO rule (True). Defaults to False. Is only used if getPriority is None.
            getPriority (Any, optional): Calculation of the priorities for the waiting clients (must be a lambda, a string that can be evaluated to a lambda, or None). If None is passed, the LIFO parameter is interpreted. Defaults to None.
            record_values (bool, optional): Record each state change? Defaults to False.
            getS_client_type (Any, optional): Dict defining services times (string or lambda) by client type (str); if there is no service time defined for a client type, the default service time from the getS parameter is used
            getNu_client_type (Any, optional): Dict defining waiting time tolerances (string or lambda) by client type (str); if there is no waiting time tolerance defined for a client type, the default service time from the getS parameter is used
        """
        super().__init__(simulator)
        self.__getS = getS
        self.__getS_client_type = getS_client_type
        self.__getS2 = getS2
        self.__getNu = getNu
        self.__getNu_client_type = getNu_client_type
        self.__c: int = c
        self.__cBusy: int = 0
        self.__K: int = K
        self.__b: int = max(1, b)
        self.__FIFO: bool = not LIFO
        self.__getPriority = getPriority
        self.__wip: int = 0
        self.__queue: list[Client] = []
        self.__nextStation: Optional[Station] = None
        self.__nextStationCancel: Optional[Station] = None
        self.__statisticStationWaiting: RecordDiscrete = RecordDiscrete()
        self.__statisticStationService: RecordDiscrete = RecordDiscrete()
        self.__statisticStationPostProcessing: RecordDiscrete = RecordDiscrete()
        self.__statisticStationResidence: RecordDiscrete = RecordDiscrete()
        self.__statisticSuccess: RecordOptions = RecordOptions()
        self.__statisticQueueLength: RecordContinuous = RecordContinuous(record_values)
        self.__statisticWIP: RecordContinuous = RecordContinuous(record_values)
        self.__statisticWorkload: RecordContinuous = RecordContinuous(record_values)

    def set_next(self, station: Station) -> None:
        """Sets the next station for successfully served clients.

        Args:
            station (Station): Next station for successfully served clients
        """
        self.__nextStation = station

    def set_next_cancel(self, station: Station) -> None:
        """Sets the next station for rejected clients and waiting cancellers.

        Args:
            station (Station): Next station for rejected clients and waiting cancellers
        """
        self.__nextStationCancel = station

    def init(self) -> None:
        super().init()
        self._update_statistic()

    def _update_statistic(self) -> None:
        time: float = self.time
        self.__statisticQueueLength.record(time, len(self.__queue))
        self.__statisticWIP.record(time, self.__wip)
        self.__statisticWorkload.record(time, self.__cBusy)

    def _send_client_to_next(self, client: Client, success: bool) -> None:
        if success:
            self.__statisticSuccess.record("Success")
            client.send_to(self.__nextStation)
        else:
            self.__statisticSuccess.record("Rejected/Canceled")
            if self.__nextStationCancel is not None:
                client.send_to(self.__nextStationCancel)
            else:
                client.send_to(self.__nextStation)

    def arrival(self, client: Client) -> None:
        super().arrival(client)

        # Queue full? - Reject client
        if self.__K > 0 and self.__wip >= self.__K:
            self._send_client_to_next(client, False)
            return

        self.__wip += 1

        # Customer joins queue
        self.__queue.append(client)
        delta: float = self._get_nu_delta(client)
        if delta > 0:
            client.removeEvent = _WaitingCancelationEvent(self.simulator, self.time + delta, self, client)

        # Check whether an service process can start
        if not self._test_start_service():
            self._update_statistic()  # On starting a service process statistic will be recorded; if not we do recording here

    def _get_nu_delta(self, client: Client) -> float:
        if self.__getNu_client_type is not None:
            client_type: str = client.type_name
            if client_type in self.__getNu_client_type:
                if isinstance(self.__getNu_client_type[client_type], str): self.__getNu_client_type[client_type] = eval(self.__getNu_client_type[client_type])
                return max(0, self.__getNu_client_type[client_type])

        if self.__getNu is not None:
            if isinstance(self.__getNu, str): self.__getNu = eval(self.__getNu)
            return max(0, self.__getNu())

        return 0

    def waiting_cancelation_event(self, client: Client) -> None:
        """Triggered by a customer's wait cancellation event. Removes the client from the station.

        Args:
            client (Client): Client who canceled waiting
        """
        self.__queue.remove(client)
        self.__wip -= 1
        client.add_waiting(self.simulator.time - client.stationArrivalTime)
        self._send_client_to_next(client, False)

    def _get_next_client_from_queue(self) -> Client:
        if self.__getPriority is None:
            # Use FIFO / LIFO if not priority lambda is given
            client: Client = self.__queue.pop(0) if self.__FIFO else self.__queue.pop(-1)
            return client
        else:
            # Calculate priorities
            if isinstance(self.__getPriority, str): self.__getPriority = eval(self.__getPriority)
            best_client: Client = self.__queue[0]
            best_priority: float = 0
            for i, c in enumerate(self.__queue):
                priority: float = self.__getPriority(c, self.simulator.time - c.stationArrivalTime)
                if i==0 or priority>best_priority:
                    best_client = c
                    best_priority = priority
            self.__queue.remove(best_client)
            return best_client

    def _test_start_service(self) -> bool:
        if len(self.__queue) < self.__b: return False
        if self.__cBusy >= self.__c: return False

        # Select client for service
        clients: list[Client] = []
        while len(clients) < self.__b:
            # Remove from queue
            client: Client = self._get_next_client_from_queue()
            clients.append(client)

            # Calculate waiting time
            waiting: float = self.time - client.stationArrivalTime
            client.add_waiting(waiting)
            self.__statisticStationWaiting.record(waiting)

            # If necessary, delete waiting cancelation event
            if client.removeEvent is not None:
                self.simulator.remove_event(client.removeEvent)
                client.removeEvent = None

        self.__cBusy += 1

        # Determine service time and start service process
        service: float = self._get_service_time(clients)
        for client in clients: client.add_service(service)
        self.__statisticStationService.record(service)
        self.generate_event(service, clients)

        self._update_statistic()
        return True

    def _get_service_time(self, clients: list) -> float:
        if isinstance(self.__getS, str): self.__getS = eval(self.__getS)

        if self.__getS_client_type is not None:
            client_types: set[str] = set()
            for client in clients:
                client_types.add(client.type_name)
            time: float = 0
            add_default: bool = False
            for client_type in client_types:
                if client_type in self.__getS_client_type:
                    if isinstance(self.__getS_client_type[client_type], str): self.__getS_client_type[client_type] = eval(self.__getS_client_type[client_type])
                    time = max(time, self.__getS_client_type[client_type]())
                else:
                    add_default = True
            if add_default and self.__getS is not None:
                time = max(time, self.__getS())
            return time
        else:
            return max(0, self.__getS()) if self.__getS is not None else 0

    def _free_operator(self) -> None:
        self.__cBusy -= 1
        if not self._test_start_service():
            self._update_statistic()  # On starting a service process statistic will be recorded; if not we do recording here

    def event(self, client) -> None:
        # End of a post processing time?
        if client is None:
            self._free_operator()
            return

        self.__wip -= len(client)
        self._update_statistic()
        for c in client: self._send_client_to_next(c, True)

        # Release operator directly or else post processing time
        if self.__getS2 is None:
            self._free_operator()
        else:
            if isinstance(self.__getS2, str): self.__getS2 = eval(self.__getS2)
            postProcessingTime: float = max(0, self.__getS2())
            self.__statisticStationPostProcessing.record(postProcessingTime)
            self.generate_event(postProcessingTime)

    @property
    def c(self) -> int:
        """Number of operators at the station

        Returns:
            int: Number of operators at the station
        """
        return self.__c

    @property
    def wip(self) -> int:
        """Current number of clients at the station (waiting and in service process)

        Returns:
            int: Current number of clients at the station (waiting and in service process)
        """
        return self.__wip

    @property
    def nq(self) -> int:
        """Current number of clients waiting in the queue at the station

        Returns:
            int: Current number of clients waiting in the queue at the station
        """
        return len(self.__queue)

    @property
    def statistic_station_waiting(self) -> RecordDiscrete:
        """Waiting times incurred at the station.

        Returns:
            RecordDiscrete: Waiting times incurred at the station
        """
        return self.__statisticStationWaiting

    @property
    def statistic_station_service(self) -> RecordDiscrete:
        """Service times incurred at the station.

        Returns:
            RecordDiscrete: Service times incurred at the station
        """
        return self.__statisticStationService

    @property
    def statistic_station_post_processing(self) -> RecordDiscrete:
        """Post processing times incurred at the station.

        Returns:
            RecordDiscrete: Post processing times incurred at the station
        """
        return self.__statisticStationPostProcessing

    @property
    def statistic_station_residence(self) -> RecordDiscrete:
        """Residence times incurred at the station.

        Returns:
            RecordDiscrete: Residence times incurred at the station
        """
        return self.__statisticStationResidence

    @property
    def statistic_success(self) -> RecordOptions:
        """Proportions of successful and unsuccessful clients.

        Returns:
            RecordOptions: Proportions of successful and unsuccessful clients
        """
        return self.__statisticSuccess

    @property
    def statistic_queue_length(self) -> RecordContinuous:
        """Queue length at the station.

        Returns:
            RecordContinuous: Queue length at the station
        """
        return self.__statisticQueueLength

    @property
    def statistic_wip(self) -> RecordContinuous:
        """Number of clients at the station (work units in process).

        Returns:
            RecordContinuous: Number of clients at the station
        """
        return self.__statisticWIP

    @property
    def statistic_workload(self) -> RecordContinuous:
        """Workload of the operators at the station.

        Returns:
            RecordContinuous: Workload of the operators at the station
        """
        return self.__statisticWorkload

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        next = []
        if self.__nextStation is not None: next.append(self.__nextStation)
        if self.__nextStationCancel is not None: next.append(self.__nextStationCancel)
        return next

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__getS = None
        self.__getS_client_type = None
        self.__getS2 = None
        self.__getNu = None
        self.__getNu_client_type = None
        self.__queue.clear()
        self.__nextStationCancel = None
        self.__statisticStationWaiting.done_recording()
        self.__statisticStationService.done_recording()
        self.__statisticStationPostProcessing.done_recording()
        self.__statisticStationResidence.done_recording()


class Decide(Station):
    """Station: Decide."""
    __slots__ = ("__rate", "__rateSum", "__station", "__statisticOptions")

    def __init__(self, simulator: Simulator) -> None:
        """Station: Decide.

        Args:
            simulator (Simulator): Simulator object
        """
        super().__init__(simulator)
        self.__rate: list[float] = []
        self.__rateSum: float = 0
        self.__station: list[Station] = []
        self.__statisticOptions: RecordOptions = RecordOptions()

    def add_next(self, station: Station, rate: float) -> None:
        """Adds a possible next station.

        Args:
            station (Station): Possible next station
            rate (float): Rate at which to branch to this next station
        """
        self.__rate.append(rate)
        self.__rateSum += rate
        self.__station.append(station)

    def arrival(self, client: Client) -> None:
        super().arrival(client)
        rnd: float = random.random() * self.__rateSum
        sum: float = 0
        optionCount: int = len(self.__rate)
        for i in range(0, optionCount):
            sum += self.__rate[i]
            if sum >= rnd:
                client.send_to(self.__station[i])
                self.__statisticOptions.record(i + 1)
                return

        client.send_to(self.__station[optionCount - 1])
        self.__statisticOptions.record(optionCount)

    @property
    def statistic_options(self) -> RecordOptions:
        """Branching frequencies to the next stations.

        Returns:
            RecordOptions: Branching frequencies to the next stations
        """
        return self.__statisticOptions

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        return self.__station

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__station.clear()


class DecideCondition(Station):
    """Station: Decide by condition."""
    __slots__ = ("__get_nr", "__station", "__statisticOptions")

    def __init__(self, simulator: Simulator) -> None:
        """Station: Decide by condition.

        Args:
            simulator (Simulator): Simulator object
        """
        super().__init__(simulator)
        self.__station: list[Station] = []
        self.__statisticOptions: RecordOptions = RecordOptions()

    def set_condition(self, get_nr: Any) -> None:
        """Sets the condition for selecting the output.

        Args:
            get_nr (Any): Function that has to return the 0-based index of the next station to be chosen
        """
        self.__get_nr: Any = get_nr

    def add_next(self, station: Station) -> None:
        """Adds a possible next station.

        Args:
            station (Station): Possible next station
        """
        self.__station.append(station)

    def arrival(self, client: Client) -> None:
        super().arrival(client)
        if isinstance(self.__get_nr, str): self.__get_nr = eval(self.__get_nr)
        nr: int = self.__get_nr(client)
        client.send_to(self.__station[nr])
        self.__statisticOptions.record(nr + 1)

    @property
    def statistic_options(self) -> RecordOptions:
        """Branching frequencies to the next stations.

        Returns:
            RecordOptions: Branching frequencies to the next stations
        """
        return self.__statisticOptions

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        return self.__station

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__get_nr = None
        self.__station.clear()


class DecideClientType(Station):
    """Station: Decide by client type."""
    __slots__ = ("__next_default", "__next")

    def __init__(self, simulator: Simulator) -> None:
        """Station: Decide by client type.

        Args:
            simulator (Simulator): Simulator object
        """
        super().__init__(simulator)
        self.__next_default: Optional[Station] = None
        self.__next: dict[str, Station] = {}

    def set_next_default(self, station: Station) -> None:
        """Sets the default next station if no client type rule matches.

        Args:
            station (Station): Default next station
        """
        self.__next_default = station

    def set_next(self, client_type: str, station: Station) -> None:
        """Sets a client type depending next station.

        Args:
            client_type (str): Client type name
            station (Station): Next station for clients of this type
        """
        self.__next[client_type] = station

    def arrival(self, client: Client) -> None:
        super().arrival(client)
        client_type: str = client.type_name
        if client_type in self.__next:
            client.send_to(self.__next[client_type])
        else:
            client.send_to(self.__next_default)

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        next = []
        if self.__next_default is not None: next.append(self.__next_default)
        for station in self.__next.values(): next.append(station)
        return next

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__next_default = None
        self.__next.clear()


class Delay(Station):
    """Station: Delay."""
    __slots__ = ("__getDelay", "__wip", "__statisticStationResidence", "__statisticWIP", "__nextStation")

    def __init__(self, simulator: Simulator, getDelay: Any, record_values: bool = False) -> None:
        """Station: Delay.

        Args:
            simulator (Simulator): Simulator object
            getDelay (Any): Generates the delay times (must be a lambda or a string that can be evaluated to a lambda)
            record_values (bool, optional): Record each state change? Defaults to False.
        """
        super().__init__(simulator)
        self.__getDelay = getDelay
        self.__wip: int = 0
        self.__statisticStationResidence: RecordDiscrete = RecordDiscrete()
        self.__statisticWIP: RecordContinuous = RecordContinuous(record_values)
        self.__nextStation = None

    def set_next(self, station: Station) -> None:
        """Sets the next station.

        Args:
            station (Station): Next station
        """
        self.__nextStation = station

    def init(self) -> None:
        super().init()
        self._update_statistic()

    def _update_statistic(self) -> None:
        self.__statisticWIP.record(self.time, self.__wip)

    def arrival(self, client: Client) -> None:
        super().arrival(client)
        self.__wip += 1
        if isinstance(self.__getDelay, str): self.__getDelay = eval(self.__getDelay)
        delay = max(0, self.__getDelay()) if self.__getDelay is not None else 0
        self.__statisticStationResidence.record(delay)
        self.generate_event(delay, client)
        self._update_statistic()

    def event(self, client: Optional[Client]) -> None:
        if client is None:
            return
        self.__wip -= 1
        self._update_statistic()
        client.send_to(self.__nextStation)

    @property
    def statistic_station_residence(self) -> RecordDiscrete:
        """Residence times at the station.

        Returns:
            RecordDiscrete: Residence times at the station
        """
        return self.__statisticStationResidence

    @property
    def statistic_wip(self) -> RecordContinuous:
        """Number of clients at the station (work units in process).

        Returns:
            RecordContinuous: Number of clients at the station
        """
        return self.__statisticWIP

    @property
    def next_stations(self) -> list:
        """Next stations

        Returns:
            list[Station]: Next stations
        """
        if self.__nextStation is None: return []
        return [self.__nextStation]

    def clear_lambdas(self) -> None:
        super().clear_lambdas()
        self.__getDelay = None
        self.__statisticStationResidence.done_recording()
